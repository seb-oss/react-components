{"version":3,"file":"component---src-pages-docs-sortable-list-tsx-8b647577d5c41a90dda6.js","mappings":"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","sources":["webpack://react-components-docs/../lib/src/SortableList/SortableList.tsx","webpack://react-components-docs/../lib/src/SortableList/SortableItem.tsx","webpack://react-components-docs/./src/pages/docs/sortable-list.tsx","webpack://react-components-docs/../lib/src/SortableList/dragtouch.polyfills.ts","webpack://react-components-docs/../lib/src/SortableList/SortableList.tsx?e347"],"sourcesContent":["import React from \"react\";\nimport classnames from \"classnames\";\nimport { SortableItemProps } from \"./SortableItem\";\nimport \"./dragtouch.polyfills\";\nimport \"./sortable-list.scss\";\nimport { Key } from \"../utils\";\n\nconst dragAndDropIcon: JSX.Element = (\n    <svg width=\"10px\" fill=\"currentColor\" height=\"16px\" viewBox=\"0 0 10 16\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlnsXlink=\"http://www.w3.org/1999/xlink\">\n        <g id=\"Symbols\" stroke=\"none\" strokeWidth=\"1\" fill=\"none\" fillRule=\"evenodd\">\n            <g id=\"Group\" fill=\"currentColor\">\n                <circle id=\"Oval\" cx=\"2\" cy=\"2\" r=\"2\" />\n                <circle id=\"Oval-Copy-2\" cx=\"2\" cy=\"8\" r=\"2\" />\n                <circle id=\"Oval-Copy-4\" cx=\"2\" cy=\"14\" r=\"2\" />\n                <circle id=\"Oval-Copy\" cx=\"8\" cy=\"2\" r=\"2\" />\n                <circle id=\"Oval-Copy-3\" cx=\"8\" cy=\"8\" r=\"2\" />\n                <circle id=\"Oval-Copy-5\" cx=\"8\" cy=\"14\" r=\"2\" />\n            </g>\n        </g>\n    </svg>\n);\n\nexport type SortableListProps = JSX.IntrinsicElements[\"div\"] & {\n    /** on sort callback */\n    onSort: (list: Array<string>) => void;\n    /** disable sorting */\n    disabled?: boolean;\n};\n\ntype PositionDelta = {\n    x: number;\n    y: number;\n};\n\ntype OrderItem = Pick<SortableItemWrapperProps, \"disabled\" | \"uniqueKey\">;\n\n/** The component allows for sorting list by drag and drop. */\nexport const SortableList: React.FC<SortableListProps> = ({ onSort, className, disabled, ...props }: React.PropsWithChildren<SortableListProps>) => {\n    const dragContainerRef = React.useRef<HTMLDivElement>();\n    const [defaultOrders, setDefaultOrders] = React.useState<OrderItem[]>([]);\n    const [draggingOrders, setDraggingOrders] = React.useState<OrderItem[]>(defaultOrders);\n    const [currentItemNode, setCurrentItemNode] = React.useState<HTMLDivElement>(null);\n    const [currentItemIndex, setCurrentItemIndex] = React.useState<number>(null);\n    const [delta, setDelta] = React.useState<PositionDelta>({ x: 0, y: 0 });\n    const [dragNode, setDragNode] = React.useState<HTMLElement>(null);\n    const [isDragging, setIsDragging] = React.useState<boolean>(false);\n    const [isTranslating, setIsTranslating] = React.useState<boolean>(false);\n    const [affectedIndex, setAffectedIndex] = React.useState<number>(null);\n    const [affectedNode, setAffectedNode] = React.useState<HTMLDivElement>(null);\n\n    /**\n     * when user clicks on sortable item, set initial delta and selected item\n     * @param event mouse event\n     * @param index selected index\n     */\n    const onMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>, index: number) => {\n        const itemParentNode: HTMLDivElement = (event.target as HTMLDivElement).closest(\".sortable-item-wrapper\");\n        const position: React.MouseEvent = ((event as React.TouchEvent).touches ? (event as React.TouchEvent).touches[0] : event) as React.MouseEvent;\n        setDelta({\n            x: position.pageX - itemParentNode.getBoundingClientRect().left,\n            y: position.pageY - itemParentNode.getBoundingClientRect().top,\n        });\n        setCurrentItemIndex(index);\n        setCurrentItemNode(itemParentNode);\n    };\n\n    /**\n     * on drag initiated, set the ghost item\n     * @param event drag event\n     */\n    const onDragStart = React.useCallback(\n        (event: React.DragEvent<HTMLDivElement>) => {\n            setIsDragging(() => {\n                const clonedNode: HTMLElement = currentItemNode.cloneNode(true) as HTMLElement;\n                clonedNode.classList.remove(\"is-active\");\n                clonedNode.classList.add(\"on-drag\");\n                clonedNode.style.width = `${currentItemNode.getBoundingClientRect().width}px`;\n                clonedNode.style.height = `${currentItemNode.getBoundingClientRect().height}px`;\n                document.body.appendChild(clonedNode);\n                event.dataTransfer.setDragImage(clonedNode, delta.x, delta.y);\n                event.dataTransfer.effectAllowed = \"move\";\n                setDragNode(clonedNode);\n                return true;\n            });\n        },\n        [currentItemNode]\n    );\n\n    /**\n     * when the dragged item is dragged over another sortable item, check if the overlapped element fulfills criteria to be swapped\n     * @param event drag event\n     * @param index overlapped index\n     */\n    const onDragOver = React.useCallback(\n        (event: React.DragEvent<HTMLDivElement>, index: number) => {\n            event.preventDefault(); // to prevent ghost image for reverting to original position\n            event.dataTransfer.dropEffect = \"move\";\n            const activeNodeRect: DOMRect = currentItemNode.getBoundingClientRect();\n            const itemParentNode: HTMLDivElement = (event.target as HTMLDivElement).closest(\".sortable-item-wrapper\");\n            const nodeRect: DOMRect = itemParentNode.getBoundingClientRect();\n            const ghostImagePositionTop: number = event.clientY - delta.y;\n            const ghostImagePositionBottom: number = ghostImagePositionTop + activeNodeRect.height; // get ghost image's actual position\n            const isAboveGhostImage: boolean = nodeRect.top <= ghostImagePositionTop;\n            let positionDifference: number = nodeRect.top - ghostImagePositionBottom;\n            if (isAboveGhostImage) {\n                positionDifference = ghostImagePositionTop - nodeRect.bottom;\n            }\n            const isHalfCoverage: boolean = Math.abs(positionDifference) / nodeRect.height >= 0.5; // only trigger swapping when overlapped coverage is more than 50%\n            const isOverlapped: boolean = isHalfCoverage && !isTranslating && itemParentNode.className.indexOf(\"on-drag\") === -1;\n            itemParentNode.style.transform = null;\n            if (isOverlapped) {\n                // if the overlapped item fulfills criteria, initiate animation\n                setIsTranslating(true);\n                itemParentNode.style.transform = `translate3d(0, ${isAboveGhostImage ? \"\" : \"-\"}${itemParentNode.offsetHeight}px, 0)`;\n                setAffectedNode(itemParentNode);\n                setAffectedIndex(index);\n            }\n        },\n        [currentItemNode, delta, setIsTranslating, setAffectedNode, setAffectedIndex]\n    );\n\n    /** sort dragging order on transition end */\n    const onTransitionEnd = React.useCallback(() => {\n        if (affectedNode) {\n            setDraggingOrders((oldOrders: OrderItem[]) => {\n                const newList: OrderItem[] = oldOrders.slice(0);\n                affectedNode.style.transform = null;\n                let itemIndex: number = currentItemIndex;\n                const originalItem: OrderItem = newList.find(({ uniqueKey }: OrderItem, index: number) => {\n                    itemIndex = index;\n                    return uniqueKey === defaultOrders[currentItemIndex].uniqueKey;\n                });\n                newList[itemIndex] = newList[affectedIndex]; // swap overlapped\n                newList[affectedIndex] = originalItem;\n                setAffectedIndex(null);\n                setAffectedNode(null);\n                setIsTranslating(false);\n                return newList;\n            });\n        }\n    }, [affectedNode, affectedIndex, setDraggingOrders, setAffectedIndex, setAffectedNode, setIsTranslating]);\n\n    /**\n     * on drag end, remove appended ghost image and style, fire on sort callback\n     * @param event drag event\n     */\n    const onDragEnd = React.useCallback(\n        (event: React.DragEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>) => {\n            setIsDragging(() => {\n                event.preventDefault(); // to prevent ghost image for reverting to original position\n                event.stopPropagation();\n                Array.from(dragContainerRef.current.children).forEach((element: HTMLElement) => {\n                    element.style.transform = null;\n                });\n                setCurrentItemIndex(null);\n                setCurrentItemNode(null);\n                onSort(draggingOrders.map(({ uniqueKey }: OrderItem) => uniqueKey));\n                setDefaultOrders(draggingOrders);\n                dragNode?.remove();\n                return false;\n            });\n        },\n        [dragContainerRef, draggingOrders, dragNode, setIsDragging, setCurrentItemIndex, setCurrentItemNode, onSort, setDefaultOrders]\n    );\n\n    const onItemSwap = React.useCallback(\n        (currentIndex: number, swapIndex: number, focusTarget: HTMLDivElement) => {\n            const newList: OrderItem[] = defaultOrders.slice(0);\n            const swapItem = newList[swapIndex];\n            newList[swapIndex] = newList[currentIndex]; // swap overlapped\n            newList[currentIndex] = swapItem;\n            onSort(newList.map(({ uniqueKey }: OrderItem) => uniqueKey));\n            setDefaultOrders(newList);\n            focusTarget.focus();\n        },\n        [defaultOrders]\n    );\n\n    const onKeyDown = React.useCallback(\n        (event: React.KeyboardEvent<HTMLDivElement>) => {\n            const selectedItemIndex: number = Number((event.target as HTMLDivElement).dataset?.index);\n            switch (event.key) {\n                case Key.Space:\n                case Key.Enter:\n                    setCurrentItemIndex((oldItemIndex: number) => (oldItemIndex === null ? selectedItemIndex : null));\n                    break;\n                case Key.ArrowRight:\n                case Key.ArrowDown:\n                    event.preventDefault();\n                    setCurrentItemIndex((oldItemIndex: number) => {\n                        if (oldItemIndex !== null && selectedItemIndex < defaultOrders.length - 1) {\n                            onItemSwap(selectedItemIndex, selectedItemIndex + 1, (event.target as HTMLDivElement).nextElementSibling as HTMLDivElement);\n                            return selectedItemIndex;\n                        }\n                        return oldItemIndex;\n                    });\n                    break;\n                case Key.ArrowLeft:\n                case Key.ArrowUp:\n                    event.preventDefault();\n                    setCurrentItemIndex((oldItemIndex: number) => {\n                        if (oldItemIndex !== null && selectedItemIndex > 0) {\n                            onItemSwap(selectedItemIndex, selectedItemIndex - 1, (event.target as HTMLDivElement).previousElementSibling as HTMLDivElement);\n                            return selectedItemIndex;\n                        }\n                        return oldItemIndex;\n                    });\n                    break;\n            }\n        },\n        [onItemSwap, defaultOrders]\n    );\n\n    React.useEffect(() => {\n        setDefaultOrders(() => {\n            const newOrderList: OrderItem[] = React.Children.toArray(props.children)\n                .filter((item: React.ReactChild) => React.isValidElement<React.FC<SortableItemProps>>(item) && (item?.type as any)?.displayName === \"SortableItem\")\n                .map(({ props }: React.ReactElement<SortableItemProps>) => ({ uniqueKey: props.uniqueKey, disabled: props.disabled }));\n            if (newOrderList.length === 0) {\n                console.warn(\"Please pass at least one SortableItem element to make SortableList works\");\n            }\n            return newOrderList;\n        });\n    }, [props.children]);\n\n    React.useEffect(() => {\n        setDraggingOrders(defaultOrders);\n    }, [defaultOrders]);\n\n    return (\n        <div role=\"application\" className={classnames(\"rc\", \"sortable-list\", className, { disabled })}>\n            <div {...props} className=\"drop-container\" tabIndex={0} role=\"list\" ref={dragContainerRef} onKeyDown={(event: React.KeyboardEvent<HTMLDivElement>) => onKeyDown(event)}>\n                {(currentItemIndex === null ? defaultOrders : draggingOrders).map((item: OrderItem, index: number) => (\n                    <SortableItemWrapper\n                        key={index}\n                        index={index}\n                        uniqueKey={item.uniqueKey}\n                        disabled={disabled || item.disabled}\n                        isActive={currentItemIndex !== null && item === defaultOrders[currentItemIndex]}\n                        isDragging={isDragging}\n                        className=\"sortable-item-wrapper\"\n                        onMouseDown={(event: React.MouseEvent<HTMLDivElement, MouseEvent>) => onMouseDown(event, index)}\n                        onTouchStart={(event: React.TouchEvent<HTMLDivElement>) => onMouseDown(event, index)}\n                        onMouseUp={onDragEnd}\n                        onTouchEnd={onDragEnd}\n                        onDragStart={onDragStart}\n                        onDragOver={isTranslating ? null : (event: React.DragEvent<HTMLDivElement>) => onDragOver(event, index)}\n                        onDragEnd={onDragEnd}\n                        onTransitionEnd={onTransitionEnd}\n                        aria-grabbed={currentItemIndex === index}\n                    >\n                        {React.Children.map(props.children, (Child: React.ReactElement<SortableItemProps>) => {\n                            const { uniqueKey }: SortableItemProps = Child.props;\n                            const isDisabled: boolean = disabled || item.disabled;\n                            return item.uniqueKey === uniqueKey && React.isValidElement<React.FC<SortableItemProps>>(Child)\n                                ? React.cloneElement(Child, {\n                                      disabled: isDisabled,\n                                      \"aria-disabled\": isDisabled,\n                                  })\n                                : null;\n                        })}\n                    </SortableItemWrapper>\n                ))}\n            </div>\n        </div>\n    );\n};\n\ntype SortableItemWrapperProps = SortableItemProps &\n    JSX.IntrinsicElements[\"div\"] & {\n        isActive?: boolean;\n        disabled?: boolean;\n        isDragging?: boolean;\n        index: number;\n    };\n\nconst SortableItemWrapper: React.FC<SortableItemWrapperProps> = ({\n    isActive,\n    isDragging,\n    className,\n    disabled,\n    children,\n    uniqueKey,\n    index,\n    onDragStart,\n    onDragOver,\n    onDragEnd,\n    onTransitionEnd,\n    onMouseDown,\n    onMouseUp,\n    onTouchEnd,\n    onTouchStart,\n    ...props\n}: React.PropsWithChildren<SortableItemWrapperProps>) => {\n    return (\n        <div\n            {...props}\n            tabIndex={0}\n            role=\"listitem\"\n            className={classnames(\"rc\", \"sortable-item-wrapper\", className, { \"is-active\": isActive && isDragging, disabled })}\n            data-value={uniqueKey}\n            data-index={index}\n            onTransitionEnd={disabled ? null : onTransitionEnd}\n            onDragOver={disabled ? null : isActive ? (event: React.DragEvent) => event.preventDefault() : onDragOver}\n        >\n            <div className=\"sort-item-content\">{children}</div>\n            <div\n                className=\"drag-icon\"\n                draggable={isActive && !disabled}\n                onMouseUp={isDragging || disabled ? null : onMouseUp}\n                onTouchEnd={isDragging || disabled ? null : onTouchEnd}\n                onMouseDown={disabled ? null : onMouseDown}\n                onTouchStart={disabled ? null : onTouchStart}\n                onDragStart={isActive || !disabled ? onDragStart : null}\n                onDragEnd={isDragging || !disabled ? onDragEnd : null}\n            >\n                {dragAndDropIcon}\n            </div>\n        </div>\n    );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\n\nexport type SortableItemProps = Omit<JSX.IntrinsicElements[\"div\"], \"onDragStart\" | \"onDragOver\" | \"onDragEnd\"> & {\n    uniqueKey: string;\n    disabled?: boolean;\n};\n\nconst SortableItem: React.FC<SortableItemProps> = React.forwardRef(\n    ({ className, disabled, children, uniqueKey, ...props }: React.PropsWithChildren<SortableItemProps>, ref: React.ForwardedRef<HTMLDivElement>) => {\n        return (\n            <div {...props} ref={ref} className={classnames(\"rc\", \"sortable-item\", className)}>\n                {React.Children.map(children, (Child: React.ReactElement) => {\n                    const isDisabled: boolean = disabled || Child.props?.disabled;\n                    return React.isValidElement<React.FC<any>>(Child)\n                        ? React.cloneElement(Child, {\n                              disabled: isDisabled,\n                              \"aria-disabled\": isDisabled,\n                          } as any)\n                        : Child;\n                })}\n            </div>\n        );\n    }\n);\n\nSortableItem.displayName = \"SortableItem\";\n\nexport { SortableItem };\n","import React from \"react\";\nimport Docs from \"@common/Docs\";\nimport { SortableList } from \"@sebgroup/react-components/SortableList\";\nimport { useDynamicForm } from \"@sebgroup/react-components/hooks/useDynamicForm\";\nimport { SortableItem } from \"@sebgroup/react-components/SortableList/SortableItem\";\nimport { Checkbox } from \"@sebgroup/react-components/Checkbox\";\n\nconst importString: string = require(\"!raw-loader!@sebgroup/react-components/SortableList/SortableList\");\nconst code: string = `<SortableList>\n    <SortableItem uniqueKey=\"item1\">item 1</SortableItem>\n    <SortableItem uniqueKey=\"item2\">item 2</SortableItem>\n    <SortableItem uniqueKey=\"item3\" disabled>item 3</SortableItem>\n</SortableList>`;\n\ntype Example = {\n    label: string;\n    value: string;\n    checked: boolean;\n    disabled?: boolean;\n};\n\nconst SortableListPage: React.FC = (): React.ReactElement<void> => {\n    const [value, setValue] = React.useState<number>(null);\n    const [array, setArray] = React.useState<Example[]>([\n        {\n            label: \"Name\",\n            value: \"1\",\n            checked: false,\n        },\n        {\n            label: \"Age\",\n            value: \"2\",\n            checked: false,\n        },\n        {\n            label: \"Company\",\n            value: \"3\",\n            checked: false,\n        },\n        {\n            label: \"Address\",\n            value: \"4\",\n            checked: false,\n        },\n    ]);\n\n    const {\n        renderForm: renderControls,\n        state: { controls },\n    } = useDynamicForm([\n        {\n            key: \"controls\",\n            items: [\n                { key: \"disabled\", label: \"disabled\", controlType: \"Checkbox\" },\n                { key: \"disabledItem\", label: \"disable one random item\", controlType: \"Checkbox\" },\n                { key: \"simple\", label: \"simple usage\", controlType: \"Checkbox\" },\n            ],\n        },\n    ]);\n\n    React.useEffect(() => {\n        setValue(controls.disabledItem ? Math.floor(Math.random() * (array.length - 1 - 0 + 1)) + 0 : null);\n    }, [controls.disabledItem]);\n\n    return (\n        <Docs\n            mainFile={importString}\n            example={\n                <div className=\"w-100 d-flex justify-content-center\">\n                    <SortableList\n                        disabled={!!controls.disabled}\n                        onSort={(list: string[]) => setArray((oldArray: Example[]) => oldArray.sort((a: Example, b: Example) => list.indexOf(a.value) - list.indexOf(b.value)))}\n                    >\n                        {array.map((item: Example, index: number) => (\n                            <SortableItem key={index} uniqueKey={item.value} disabled={index === value}>\n                                {controls.simple ? (\n                                    item.label\n                                ) : (\n                                    <Checkbox\n                                        name=\"test\"\n                                        value={item.value}\n                                        checked={item.checked}\n                                        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {\n                                            setArray((oldArray: Example[]) =>\n                                                oldArray.map((checkbox: Example) => ({\n                                                    ...checkbox,\n                                                    checked: item.value === checkbox.value ? event.target.checked : checkbox.checked,\n                                                }))\n                                            );\n                                        }}\n                                    >\n                                        {item.label}\n                                    </Checkbox>\n                                )}\n                            </SortableItem>\n                        ))}\n                    </SortableList>\n                </div>\n            }\n            code={code}\n            controls={<>{renderControls()}</>}\n        />\n    );\n};\n\nexport default SortableListPage;\n","// tslint:disable\n/**\n * drag drop touch polyfill from https://github.com/Bernardo-Castilho/dragdroptouch/blob/master/DragDropTouch.js\n * credits to: https://github.com/Bernardo-Castilho\n */\n// This solution is meant to fix Gatsby build which complains that document doesn't exist in server-side rendering\nconst safeDocument: Document | null = typeof document !== \"undefined\" ? document : null;\nconst safeNavigator: Navigator | null = typeof navigator !== \"undefined\" ? navigator : null;\nvar DragDropTouch;\n(function (DragDropTouch_1) {\n    \"use strict\";\n    /**\n     * Object used to hold the data that is being dragged during drag and drop operations.\n     *\n     * It may hold one or more data items of different types. For more information about\n     * drag and drop operations and data transfer objects, see\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer\">HTML Drag and Drop API</a>.\n     *\n     * This object is created automatically by the @see:DragDropTouch singleton and is\n     * accessible through the @see:dataTransfer property of all drag events.\n     */\n    var DataTransfer = (function () {\n        function DataTransfer() {\n            this._dropEffect = \"move\";\n            this._effectAllowed = \"all\";\n            this._data = {};\n        }\n        Object.defineProperty(DataTransfer.prototype, \"dropEffect\", {\n            /**\n             * Gets or sets the type of drag-and-drop operation currently selected.\n             * The value must be 'none',  'copy',  'link', or 'move'.\n             */\n            get: function () {\n                return this._dropEffect;\n            },\n            set: function (value) {\n                this._dropEffect = value;\n            },\n            enumerable: true,\n            configurable: true,\n        });\n        Object.defineProperty(DataTransfer.prototype, \"effectAllowed\", {\n            /**\n             * Gets or sets the types of operations that are possible.\n             * Must be one of 'none', 'copy', 'copyLink', 'copyMove', 'link',\n             * 'linkMove', 'move', 'all' or 'uninitialized'.\n             */\n            get: function () {\n                return this._effectAllowed;\n            },\n            set: function (value) {\n                this._effectAllowed = value;\n            },\n            enumerable: true,\n            configurable: true,\n        });\n        Object.defineProperty(DataTransfer.prototype, \"types\", {\n            /**\n             * Gets an array of strings giving the formats that were set in the @see:dragstart event.\n             */\n            get: function () {\n                return Object.keys(this._data);\n            },\n            enumerable: true,\n            configurable: true,\n        });\n        /**\n         * Removes the data associated with a given type.\n         *\n         * The type argument is optional. If the type is empty or not specified, the data\n         * associated with all types is removed. If data for the specified type does not exist,\n         * or the data transfer contains no data, this method will have no effect.\n         *\n         * @param type Type of data to remove.\n         */\n        DataTransfer.prototype.clearData = function (type) {\n            if (type != null) {\n                delete this._data[type.toLowerCase()];\n            } else {\n                this._data = {};\n            }\n        };\n        /**\n         * Retrieves the data for a given type, or an empty string if data for that type does\n         * not exist or the data transfer contains no data.\n         *\n         * @param type Type of data to retrieve.\n         */\n        DataTransfer.prototype.getData = function (type) {\n            return this._data[type.toLowerCase()] || \"\";\n        };\n        /**\n         * Set the data for a given type.\n         *\n         * For a list of recommended drag types, please see\n         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Recommended_Drag_Types.\n         *\n         * @param type Type of data to add.\n         * @param value Data to add.\n         */\n        DataTransfer.prototype.setData = function (type, value) {\n            this._data[type.toLowerCase()] = value;\n        };\n        /**\n         * Set the image to be used for dragging if a custom one is desired.\n         *\n         * @param img An image element to use as the drag feedback image.\n         * @param offsetX The horizontal offset within the image.\n         * @param offsetY The vertical offset within the image.\n         */\n        DataTransfer.prototype.setDragImage = function (img, offsetX, offsetY) {\n            var ddt = (DragDropTouch as any)._instance;\n            ddt._imgCustom = img;\n            ddt._imgOffset = { x: offsetX, y: offsetY };\n        };\n        return DataTransfer;\n    })();\n    DragDropTouch_1.DataTransfer = DataTransfer;\n    /**\n     * Defines a class that adds support for touch-based HTML5 drag/drop operations.\n     *\n     * The @see:DragDropTouch class listens to touch events and raises the\n     * appropriate HTML5 drag/drop events as if the events had been caused\n     * by mouse actions.\n     *\n     * The purpose of this class is to enable using existing, standard HTML5\n     * drag/drop code on mobile devices running IOS or Android.\n     *\n     * To use, include the DragDropTouch.js file on the page. The class will\n     * automatically start monitoring touch events and will raise the HTML5\n     * drag drop events (dragstart, dragenter, dragleave, drop, dragend) which\n     * should be handled by the application.\n     *\n     * For details and examples on HTML drag and drop, see\n     * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_operations.\n     */\n    const DragDropTouch = (function () {\n        /**\n         * Initializes the single instance of the @see:DragDropTouch class.\n         */\n        function DragDropTouch() {\n            this._lastClick = 0;\n            // enforce singleton pattern\n            if ((DragDropTouch as any)._instance) {\n                throw \"DragDropTouch instance already created.\";\n            }\n            // detect passive event support\n            // https://github.com/Modernizr/Modernizr/issues/1894\n            var supportsPassive = false;\n            safeDocument?.addEventListener(\"test\", function () {}, {\n                get passive() {\n                    supportsPassive = true;\n                    return true;\n                },\n            });\n            // listen to touch events\n            if (safeNavigator?.maxTouchPoints) {\n                var d = safeDocument,\n                    ts = this._touchstart.bind(this),\n                    tm = this._touchmove.bind(this),\n                    te = this._touchend.bind(this),\n                    opt = supportsPassive ? { passive: false, capture: false } : false;\n                d.addEventListener(\"touchstart\", ts, opt);\n                d.addEventListener(\"touchmove\", tm, opt);\n                d.addEventListener(\"touchend\", te);\n                d.addEventListener(\"touchcancel\", te);\n            }\n        }\n        /**\n         * Gets a reference to the @see:DragDropTouch singleton.\n         */\n        DragDropTouch.getInstance = function () {\n            return (DragDropTouch as any)._instance;\n        };\n        // ** event handlers\n        DragDropTouch.prototype._touchstart = function (e) {\n            var _this = this;\n            if (this._shouldHandle(e)) {\n                // raise double-click and prevent zooming\n                if (Date.now() - this._lastClick < (DragDropTouch as any)._DBLCLICK) {\n                    if (this._dispatchEvent(e, \"dblclick\", e.target)) {\n                        e.preventDefault();\n                        this._reset();\n                        return;\n                    }\n                }\n                // clear all variables\n                this._reset();\n                // get nearest draggable element\n                var src = this._closestDraggable(e.target);\n                if (src) {\n                    // give caller a chance to handle the hover/move events\n                    if (!this._dispatchEvent(e, \"mousemove\", e.target) && !this._dispatchEvent(e, \"mousedown\", e.target)) {\n                        // get ready to start dragging\n                        this._dragSource = src;\n                        this._ptDown = this._getPoint(e);\n                        this._lastTouch = e;\n                        e.preventDefault();\n                        // show context menu if the user hasn't started dragging after a while\n                        setTimeout(function () {\n                            if (_this._dragSource == src && _this._img == null) {\n                                if (_this._dispatchEvent(e, \"contextmenu\", src)) {\n                                    _this._reset();\n                                }\n                            }\n                        }, (DragDropTouch as any)._CTXMENU);\n                        if ((DragDropTouch as any)._ISPRESSHOLDMODE) {\n                            this._pressHoldInterval = setTimeout(function () {\n                                _this._isDragEnabled = true;\n                                _this._touchmove(e);\n                            }, (DragDropTouch as any)._PRESSHOLDAWAIT);\n                        }\n                    }\n                }\n            }\n        };\n        DragDropTouch.prototype._touchmove = function (e) {\n            if (this._shouldCancelPressHoldMove(e)) {\n                this._reset();\n                return;\n            }\n            if (this._shouldHandleMove(e) || this._shouldHandlePressHoldMove(e)) {\n                // see if target wants to handle move\n                var target = this._getTarget(e);\n                if (this._dispatchEvent(e, \"mousemove\", target)) {\n                    this._lastTouch = e;\n                    e.preventDefault();\n                    return;\n                }\n                // start dragging\n                if (this._dragSource && !this._img && this._shouldStartDragging(e)) {\n                    this._dispatchEvent(e, \"dragstart\", this._dragSource);\n                    this._createImage(e);\n                    this._dispatchEvent(e, \"dragenter\", target);\n                }\n                // continue dragging\n                if (this._img) {\n                    this._lastTouch = e;\n                    e.preventDefault(); // prevent scrolling\n                    this._dispatchEvent(e, \"drag\", this._dragSource);\n                    if (target != this._lastTarget) {\n                        this._dispatchEvent(this._lastTouch, \"dragleave\", this._lastTarget);\n                        this._dispatchEvent(e, \"dragenter\", target);\n                        this._lastTarget = target;\n                    }\n                    this._moveImage(e);\n                    this._isDropZone = this._dispatchEvent(e, \"dragover\", target);\n                }\n            }\n        };\n        DragDropTouch.prototype._touchend = function (e) {\n            if (this._shouldHandle(e)) {\n                // see if target wants to handle up\n                if (this._dispatchEvent(this._lastTouch, \"mouseup\", e.target)) {\n                    e.preventDefault();\n                    return;\n                }\n                // user clicked the element but didn't drag, so clear the source and simulate a click\n                if (!this._img) {\n                    this._dragSource = null;\n                    this._dispatchEvent(this._lastTouch, \"click\", e.target);\n                    this._lastClick = Date.now();\n                }\n                // finish dragging\n                this._destroyImage();\n                if (this._dragSource) {\n                    if (e.type.indexOf(\"cancel\") < 0 && this._isDropZone) {\n                        this._dispatchEvent(this._lastTouch, \"drop\", this._lastTarget);\n                    }\n                    this._dispatchEvent(this._lastTouch, \"dragend\", this._dragSource);\n                    this._reset();\n                }\n            }\n        };\n        // ** utilities\n        // ignore events that have been handled or that involve more than one touch\n        DragDropTouch.prototype._shouldHandle = function (e) {\n            return e && !e.defaultPrevented && e.touches && e.touches.length < 2;\n        };\n\n        // use regular condition outside of press & hold mode\n        DragDropTouch.prototype._shouldHandleMove = function (e) {\n            return !(DragDropTouch as any)._ISPRESSHOLDMODE && this._shouldHandle(e);\n        };\n\n        // allow to handle moves that involve many touches for press & hold\n        DragDropTouch.prototype._shouldHandlePressHoldMove = function (e) {\n            return (DragDropTouch as any)._ISPRESSHOLDMODE && this._isDragEnabled && e && e.touches && e.touches.length;\n        };\n\n        // reset data if user drags without pressing & holding\n        DragDropTouch.prototype._shouldCancelPressHoldMove = function (e) {\n            return (DragDropTouch as any)._ISPRESSHOLDMODE && !this._isDragEnabled && this._getDelta(e) > (DragDropTouch as any)._PRESSHOLDMARGIN;\n        };\n\n        // start dragging when specified delta is detected\n        DragDropTouch.prototype._shouldStartDragging = function (e) {\n            var delta = this._getDelta(e);\n            return delta > (DragDropTouch as any)._THRESHOLD || ((DragDropTouch as any)._ISPRESSHOLDMODE && delta >= (DragDropTouch as any)._PRESSHOLDTHRESHOLD);\n        };\n\n        // clear all members\n        DragDropTouch.prototype._reset = function () {\n            this._destroyImage();\n            this._dragSource = null;\n            this._lastTouch = null;\n            this._lastTarget = null;\n            this._ptDown = null;\n            this._isDragEnabled = false;\n            this._isDropZone = false;\n            this._dataTransfer = new DataTransfer();\n            clearInterval(this._pressHoldInterval);\n        };\n        // get point for a touch event\n        DragDropTouch.prototype._getPoint = function (e, page) {\n            if (e && e.touches) {\n                e = e.touches[0];\n            }\n            return { x: page ? e.pageX : e.clientX, y: page ? e.pageY : e.clientY };\n        };\n        // get distance between the current touch event and the first one\n        DragDropTouch.prototype._getDelta = function (e) {\n            if ((DragDropTouch as any)._ISPRESSHOLDMODE && !this._ptDown) {\n                return 0;\n            }\n            var p = this._getPoint(e);\n            return Math.abs(p.x - this._ptDown.x) + Math.abs(p.y - this._ptDown.y);\n        };\n        // get the element at a given touch event\n        DragDropTouch.prototype._getTarget = function (e) {\n            var pt = this._getPoint(e),\n                el = safeDocument?.elementFromPoint(pt.x, pt.y);\n            while (el && getComputedStyle(el).pointerEvents == \"none\") {\n                el = el.parentElement;\n            }\n            return el;\n        };\n        // create drag image from source element\n        DragDropTouch.prototype._createImage = function (e) {\n            // just in case...\n            if (this._img) {\n                this._destroyImage();\n            }\n            // create drag image from custom element or drag source\n            var src = this._imgCustom || this._dragSource;\n            this._img = src.cloneNode(true);\n            this._copyStyle(src, this._img);\n            this._img.style.top = this._img.style.left = \"-9999px\";\n            // if creating from drag source, apply offset and opacity\n            if (!this._imgCustom) {\n                var rc = src.getBoundingClientRect(),\n                    pt = this._getPoint(e);\n                this._imgOffset = { x: pt.x - rc.left, y: pt.y - rc.top };\n                this._img.style.opacity = (DragDropTouch as any)._OPACITY.toString();\n            }\n            // add image to document\n            this._moveImage(e);\n            safeDocument?.body.appendChild(this._img);\n        };\n        // dispose of drag image element\n        DragDropTouch.prototype._destroyImage = function () {\n            if (this._img && this._img.parentElement) {\n                this._img.parentElement.removeChild(this._img);\n            }\n            this._img = null;\n            this._imgCustom = null;\n        };\n        // move the drag image element\n        DragDropTouch.prototype._moveImage = function (e) {\n            var _this = this;\n            requestAnimationFrame(function () {\n                if (_this._img) {\n                    var pt = _this._getPoint(e, true),\n                        s = _this._img.style;\n                    s.position = \"absolute\";\n                    s.pointerEvents = \"none\";\n                    s.zIndex = \"999999\";\n                    s.left = Math.round(pt.x - _this._imgOffset.x) + \"px\";\n                    s.top = Math.round(pt.y - _this._imgOffset.y) + \"px\";\n                }\n            });\n        };\n        // copy properties from an object to another\n        DragDropTouch.prototype._copyProps = function (dst, src, props) {\n            for (var i = 0; i < props.length; i++) {\n                var p = props[i];\n                dst[p] = src[p];\n            }\n        };\n        DragDropTouch.prototype._copyStyle = function (src, dst) {\n            // remove potentially troublesome attributes\n            (DragDropTouch as any)._rmvAtts.forEach(function (att) {\n                dst.removeAttribute(att);\n            });\n            // copy canvas content\n            if (src instanceof HTMLCanvasElement) {\n                var cSrc = src,\n                    cDst = dst;\n                cDst.width = cSrc.width;\n                cDst.height = cSrc.height;\n                cDst.getContext(\"2d\").drawImage(cSrc, 0, 0);\n            }\n            // copy style (without transitions)\n            var cs = getComputedStyle(src);\n            for (var i = 0; i < cs.length; i++) {\n                var key = cs[i];\n                if (key.indexOf(\"transition\") < 0) {\n                    dst.style[key] = cs[key];\n                }\n            }\n            dst.style.pointerEvents = \"none\";\n            // and repeat for all children\n            for (var i = 0; i < src.children.length; i++) {\n                this._copyStyle(src.children[i], dst.children[i]);\n            }\n        };\n        DragDropTouch.prototype._dispatchEvent = function (e, type, target) {\n            if (e && target) {\n                var evt = safeDocument?.createEvent(\"Event\"),\n                    t = e.touches ? e.touches[0] : e;\n                evt.initEvent(type, true, true);\n                (evt as any).button = 0;\n                (evt as any).which = (evt as any).buttons = 1;\n                this._copyProps(evt, e, (DragDropTouch as any)._kbdProps);\n                this._copyProps(evt, t, (DragDropTouch as any)._ptProps);\n                (evt as any).dataTransfer = this._dataTransfer;\n                target.dispatchEvent(evt);\n                return evt.defaultPrevented;\n            }\n            return false;\n        };\n        // gets an element's closest draggable ancestor\n        DragDropTouch.prototype._closestDraggable = function (e) {\n            for (; e; e = e.parentElement) {\n                if (e.hasAttribute(\"draggable\") && e.draggable) {\n                    return e;\n                }\n            }\n            return null;\n        };\n        return DragDropTouch;\n    })();\n    /*private*/ (DragDropTouch as any)._instance = new DragDropTouch(); // singleton\n    // constants\n    (DragDropTouch as any)._THRESHOLD = 5; // pixels to move before drag starts\n    (DragDropTouch as any)._OPACITY = 0.5; // drag image opacity\n    (DragDropTouch as any)._DBLCLICK = 500; // max ms between clicks in a double click\n    (DragDropTouch as any)._CTXMENU = 900; // ms to hold before raising 'contextmenu' event\n    (DragDropTouch as any)._ISPRESSHOLDMODE = false; // decides of press & hold mode presence\n    (DragDropTouch as any)._PRESSHOLDAWAIT = 400; // ms to wait before press & hold is detected\n    (DragDropTouch as any)._PRESSHOLDMARGIN = 25; // pixels that finger might shiver while pressing\n    (DragDropTouch as any)._PRESSHOLDTHRESHOLD = 0; // pixels to move before drag starts\n    // copy styles/attributes from drag source to drag image element\n    (DragDropTouch as any)._rmvAtts = \"id,class,style,draggable\".split(\",\");\n    // synthesize and dispatch an event\n    // returns true if the event has been handled (e.preventDefault == true)\n    (DragDropTouch as any)._kbdProps = \"altKey,ctrlKey,metaKey,shiftKey\".split(\",\");\n    (DragDropTouch as any)._ptProps = \"pageX,pageY,clientX,clientY,screenX,screenY,offsetX,offsetY\".split(\",\");\n    DragDropTouch_1.DragDropTouch = DragDropTouch;\n})(DragDropTouch || (DragDropTouch = {}));\n","export default \"import React from \\\"react\\\";\\nimport classnames from \\\"classnames\\\";\\nimport { SortableItemProps } from \\\"./SortableItem\\\";\\nimport \\\"./dragtouch.polyfills\\\";\\nimport \\\"./sortable-list.scss\\\";\\nimport { Key } from \\\"../utils\\\";\\n\\nconst dragAndDropIcon: JSX.Element = (\\n    <svg width=\\\"10px\\\" fill=\\\"currentColor\\\" height=\\\"16px\\\" viewBox=\\\"0 0 10 16\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlnsXlink=\\\"http://www.w3.org/1999/xlink\\\">\\n        <g id=\\\"Symbols\\\" stroke=\\\"none\\\" strokeWidth=\\\"1\\\" fill=\\\"none\\\" fillRule=\\\"evenodd\\\">\\n            <g id=\\\"Group\\\" fill=\\\"currentColor\\\">\\n                <circle id=\\\"Oval\\\" cx=\\\"2\\\" cy=\\\"2\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy-2\\\" cx=\\\"2\\\" cy=\\\"8\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy-4\\\" cx=\\\"2\\\" cy=\\\"14\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy\\\" cx=\\\"8\\\" cy=\\\"2\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy-3\\\" cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy-5\\\" cx=\\\"8\\\" cy=\\\"14\\\" r=\\\"2\\\" />\\n            </g>\\n        </g>\\n    </svg>\\n);\\n\\nexport type SortableListProps = JSX.IntrinsicElements[\\\"div\\\"] & {\\n    /** on sort callback */\\n    onSort: (list: Array<string>) => void;\\n    /** disable sorting */\\n    disabled?: boolean;\\n};\\n\\ntype PositionDelta = {\\n    x: number;\\n    y: number;\\n};\\n\\ntype OrderItem = Pick<SortableItemWrapperProps, \\\"disabled\\\" | \\\"uniqueKey\\\">;\\n\\n/** The component allows for sorting list by drag and drop. */\\nexport const SortableList: React.FC<SortableListProps> = ({ onSort, className, disabled, ...props }: React.PropsWithChildren<SortableListProps>) => {\\n    const dragContainerRef = React.useRef<HTMLDivElement>();\\n    const [defaultOrders, setDefaultOrders] = React.useState<OrderItem[]>([]);\\n    const [draggingOrders, setDraggingOrders] = React.useState<OrderItem[]>(defaultOrders);\\n    const [currentItemNode, setCurrentItemNode] = React.useState<HTMLDivElement>(null);\\n    const [currentItemIndex, setCurrentItemIndex] = React.useState<number>(null);\\n    const [delta, setDelta] = React.useState<PositionDelta>({ x: 0, y: 0 });\\n    const [dragNode, setDragNode] = React.useState<HTMLElement>(null);\\n    const [isDragging, setIsDragging] = React.useState<boolean>(false);\\n    const [isTranslating, setIsTranslating] = React.useState<boolean>(false);\\n    const [affectedIndex, setAffectedIndex] = React.useState<number>(null);\\n    const [affectedNode, setAffectedNode] = React.useState<HTMLDivElement>(null);\\n\\n    /**\\n     * when user clicks on sortable item, set initial delta and selected item\\n     * @param event mouse event\\n     * @param index selected index\\n     */\\n    const onMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>, index: number) => {\\n        const itemParentNode: HTMLDivElement = (event.target as HTMLDivElement).closest(\\\".sortable-item-wrapper\\\");\\n        const position: React.MouseEvent = ((event as React.TouchEvent).touches ? (event as React.TouchEvent).touches[0] : event) as React.MouseEvent;\\n        setDelta({\\n            x: position.pageX - itemParentNode.getBoundingClientRect().left,\\n            y: position.pageY - itemParentNode.getBoundingClientRect().top,\\n        });\\n        setCurrentItemIndex(index);\\n        setCurrentItemNode(itemParentNode);\\n    };\\n\\n    /**\\n     * on drag initiated, set the ghost item\\n     * @param event drag event\\n     */\\n    const onDragStart = React.useCallback(\\n        (event: React.DragEvent<HTMLDivElement>) => {\\n            setIsDragging(() => {\\n                const clonedNode: HTMLElement = currentItemNode.cloneNode(true) as HTMLElement;\\n                clonedNode.classList.remove(\\\"is-active\\\");\\n                clonedNode.classList.add(\\\"on-drag\\\");\\n                clonedNode.style.width = `${currentItemNode.getBoundingClientRect().width}px`;\\n                clonedNode.style.height = `${currentItemNode.getBoundingClientRect().height}px`;\\n                document.body.appendChild(clonedNode);\\n                event.dataTransfer.setDragImage(clonedNode, delta.x, delta.y);\\n                event.dataTransfer.effectAllowed = \\\"move\\\";\\n                setDragNode(clonedNode);\\n                return true;\\n            });\\n        },\\n        [currentItemNode]\\n    );\\n\\n    /**\\n     * when the dragged item is dragged over another sortable item, check if the overlapped element fulfills criteria to be swapped\\n     * @param event drag event\\n     * @param index overlapped index\\n     */\\n    const onDragOver = React.useCallback(\\n        (event: React.DragEvent<HTMLDivElement>, index: number) => {\\n            event.preventDefault(); // to prevent ghost image for reverting to original position\\n            event.dataTransfer.dropEffect = \\\"move\\\";\\n            const activeNodeRect: DOMRect = currentItemNode.getBoundingClientRect();\\n            const itemParentNode: HTMLDivElement = (event.target as HTMLDivElement).closest(\\\".sortable-item-wrapper\\\");\\n            const nodeRect: DOMRect = itemParentNode.getBoundingClientRect();\\n            const ghostImagePositionTop: number = event.clientY - delta.y;\\n            const ghostImagePositionBottom: number = ghostImagePositionTop + activeNodeRect.height; // get ghost image's actual position\\n            const isAboveGhostImage: boolean = nodeRect.top <= ghostImagePositionTop;\\n            let positionDifference: number = nodeRect.top - ghostImagePositionBottom;\\n            if (isAboveGhostImage) {\\n                positionDifference = ghostImagePositionTop - nodeRect.bottom;\\n            }\\n            const isHalfCoverage: boolean = Math.abs(positionDifference) / nodeRect.height >= 0.5; // only trigger swapping when overlapped coverage is more than 50%\\n            const isOverlapped: boolean = isHalfCoverage && !isTranslating && itemParentNode.className.indexOf(\\\"on-drag\\\") === -1;\\n            itemParentNode.style.transform = null;\\n            if (isOverlapped) {\\n                // if the overlapped item fulfills criteria, initiate animation\\n                setIsTranslating(true);\\n                itemParentNode.style.transform = `translate3d(0, ${isAboveGhostImage ? \\\"\\\" : \\\"-\\\"}${itemParentNode.offsetHeight}px, 0)`;\\n                setAffectedNode(itemParentNode);\\n                setAffectedIndex(index);\\n            }\\n        },\\n        [currentItemNode, delta, setIsTranslating, setAffectedNode, setAffectedIndex]\\n    );\\n\\n    /** sort dragging order on transition end */\\n    const onTransitionEnd = React.useCallback(() => {\\n        if (affectedNode) {\\n            setDraggingOrders((oldOrders: OrderItem[]) => {\\n                const newList: OrderItem[] = oldOrders.slice(0);\\n                affectedNode.style.transform = null;\\n                let itemIndex: number = currentItemIndex;\\n                const originalItem: OrderItem = newList.find(({ uniqueKey }: OrderItem, index: number) => {\\n                    itemIndex = index;\\n                    return uniqueKey === defaultOrders[currentItemIndex].uniqueKey;\\n                });\\n                newList[itemIndex] = newList[affectedIndex]; // swap overlapped\\n                newList[affectedIndex] = originalItem;\\n                setAffectedIndex(null);\\n                setAffectedNode(null);\\n                setIsTranslating(false);\\n                return newList;\\n            });\\n        }\\n    }, [affectedNode, affectedIndex, setDraggingOrders, setAffectedIndex, setAffectedNode, setIsTranslating]);\\n\\n    /**\\n     * on drag end, remove appended ghost image and style, fire on sort callback\\n     * @param event drag event\\n     */\\n    const onDragEnd = React.useCallback(\\n        (event: React.DragEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>) => {\\n            setIsDragging(() => {\\n                event.preventDefault(); // to prevent ghost image for reverting to original position\\n                event.stopPropagation();\\n                Array.from(dragContainerRef.current.children).forEach((element: HTMLElement) => {\\n                    element.style.transform = null;\\n                });\\n                setCurrentItemIndex(null);\\n                setCurrentItemNode(null);\\n                onSort(draggingOrders.map(({ uniqueKey }: OrderItem) => uniqueKey));\\n                setDefaultOrders(draggingOrders);\\n                dragNode?.remove();\\n                return false;\\n            });\\n        },\\n        [dragContainerRef, draggingOrders, dragNode, setIsDragging, setCurrentItemIndex, setCurrentItemNode, onSort, setDefaultOrders]\\n    );\\n\\n    const onItemSwap = React.useCallback(\\n        (currentIndex: number, swapIndex: number, focusTarget: HTMLDivElement) => {\\n            const newList: OrderItem[] = defaultOrders.slice(0);\\n            const swapItem = newList[swapIndex];\\n            newList[swapIndex] = newList[currentIndex]; // swap overlapped\\n            newList[currentIndex] = swapItem;\\n            onSort(newList.map(({ uniqueKey }: OrderItem) => uniqueKey));\\n            setDefaultOrders(newList);\\n            focusTarget.focus();\\n        },\\n        [defaultOrders]\\n    );\\n\\n    const onKeyDown = React.useCallback(\\n        (event: React.KeyboardEvent<HTMLDivElement>) => {\\n            const selectedItemIndex: number = Number((event.target as HTMLDivElement).dataset?.index);\\n            switch (event.key) {\\n                case Key.Space:\\n                case Key.Enter:\\n                    setCurrentItemIndex((oldItemIndex: number) => (oldItemIndex === null ? selectedItemIndex : null));\\n                    break;\\n                case Key.ArrowRight:\\n                case Key.ArrowDown:\\n                    event.preventDefault();\\n                    setCurrentItemIndex((oldItemIndex: number) => {\\n                        if (oldItemIndex !== null && selectedItemIndex < defaultOrders.length - 1) {\\n                            onItemSwap(selectedItemIndex, selectedItemIndex + 1, (event.target as HTMLDivElement).nextElementSibling as HTMLDivElement);\\n                            return selectedItemIndex;\\n                        }\\n                        return oldItemIndex;\\n                    });\\n                    break;\\n                case Key.ArrowLeft:\\n                case Key.ArrowUp:\\n                    event.preventDefault();\\n                    setCurrentItemIndex((oldItemIndex: number) => {\\n                        if (oldItemIndex !== null && selectedItemIndex > 0) {\\n                            onItemSwap(selectedItemIndex, selectedItemIndex - 1, (event.target as HTMLDivElement).previousElementSibling as HTMLDivElement);\\n                            return selectedItemIndex;\\n                        }\\n                        return oldItemIndex;\\n                    });\\n                    break;\\n            }\\n        },\\n        [onItemSwap, defaultOrders]\\n    );\\n\\n    React.useEffect(() => {\\n        setDefaultOrders(() => {\\n            const newOrderList: OrderItem[] = React.Children.toArray(props.children)\\n                .filter((item: React.ReactChild) => React.isValidElement<React.FC<SortableItemProps>>(item) && (item?.type as any)?.displayName === \\\"SortableItem\\\")\\n                .map(({ props }: React.ReactElement<SortableItemProps>) => ({ uniqueKey: props.uniqueKey, disabled: props.disabled }));\\n            if (newOrderList.length === 0) {\\n                console.warn(\\\"Please pass at least one SortableItem element to make SortableList works\\\");\\n            }\\n            return newOrderList;\\n        });\\n    }, [props.children]);\\n\\n    React.useEffect(() => {\\n        setDraggingOrders(defaultOrders);\\n    }, [defaultOrders]);\\n\\n    return (\\n        <div role=\\\"application\\\" className={classnames(\\\"rc\\\", \\\"sortable-list\\\", className, { disabled })}>\\n            <div {...props} className=\\\"drop-container\\\" tabIndex={0} role=\\\"list\\\" ref={dragContainerRef} onKeyDown={(event: React.KeyboardEvent<HTMLDivElement>) => onKeyDown(event)}>\\n                {(currentItemIndex === null ? defaultOrders : draggingOrders).map((item: OrderItem, index: number) => (\\n                    <SortableItemWrapper\\n                        key={index}\\n                        index={index}\\n                        uniqueKey={item.uniqueKey}\\n                        disabled={disabled || item.disabled}\\n                        isActive={currentItemIndex !== null && item === defaultOrders[currentItemIndex]}\\n                        isDragging={isDragging}\\n                        className=\\\"sortable-item-wrapper\\\"\\n                        onMouseDown={(event: React.MouseEvent<HTMLDivElement, MouseEvent>) => onMouseDown(event, index)}\\n                        onTouchStart={(event: React.TouchEvent<HTMLDivElement>) => onMouseDown(event, index)}\\n                        onMouseUp={onDragEnd}\\n                        onTouchEnd={onDragEnd}\\n                        onDragStart={onDragStart}\\n                        onDragOver={isTranslating ? null : (event: React.DragEvent<HTMLDivElement>) => onDragOver(event, index)}\\n                        onDragEnd={onDragEnd}\\n                        onTransitionEnd={onTransitionEnd}\\n                        aria-grabbed={currentItemIndex === index}\\n                    >\\n                        {React.Children.map(props.children, (Child: React.ReactElement<SortableItemProps>) => {\\n                            const { uniqueKey }: SortableItemProps = Child.props;\\n                            const isDisabled: boolean = disabled || item.disabled;\\n                            return item.uniqueKey === uniqueKey && React.isValidElement<React.FC<SortableItemProps>>(Child)\\n                                ? React.cloneElement(Child, {\\n                                      disabled: isDisabled,\\n                                      \\\"aria-disabled\\\": isDisabled,\\n                                  })\\n                                : null;\\n                        })}\\n                    </SortableItemWrapper>\\n                ))}\\n            </div>\\n        </div>\\n    );\\n};\\n\\ntype SortableItemWrapperProps = SortableItemProps &\\n    JSX.IntrinsicElements[\\\"div\\\"] & {\\n        isActive?: boolean;\\n        disabled?: boolean;\\n        isDragging?: boolean;\\n        index: number;\\n    };\\n\\nconst SortableItemWrapper: React.FC<SortableItemWrapperProps> = ({\\n    isActive,\\n    isDragging,\\n    className,\\n    disabled,\\n    children,\\n    uniqueKey,\\n    index,\\n    onDragStart,\\n    onDragOver,\\n    onDragEnd,\\n    onTransitionEnd,\\n    onMouseDown,\\n    onMouseUp,\\n    onTouchEnd,\\n    onTouchStart,\\n    ...props\\n}: React.PropsWithChildren<SortableItemWrapperProps>) => {\\n    return (\\n        <div\\n            {...props}\\n            tabIndex={0}\\n            role=\\\"listitem\\\"\\n            className={classnames(\\\"rc\\\", \\\"sortable-item-wrapper\\\", className, { \\\"is-active\\\": isActive && isDragging, disabled })}\\n            data-value={uniqueKey}\\n            data-index={index}\\n            onTransitionEnd={disabled ? null : onTransitionEnd}\\n            onDragOver={disabled ? null : isActive ? (event: React.DragEvent) => event.preventDefault() : onDragOver}\\n        >\\n            <div className=\\\"sort-item-content\\\">{children}</div>\\n            <div\\n                className=\\\"drag-icon\\\"\\n                draggable={isActive && !disabled}\\n                onMouseUp={isDragging || disabled ? null : onMouseUp}\\n                onTouchEnd={isDragging || disabled ? null : onTouchEnd}\\n                onMouseDown={disabled ? null : onMouseDown}\\n                onTouchStart={disabled ? null : onTouchStart}\\n                onDragStart={isActive || !disabled ? onDragStart : null}\\n                onDragEnd={isDragging || !disabled ? onDragEnd : null}\\n            >\\n                {dragAndDropIcon}\\n            </div>\\n        </div>\\n    );\\n};\\n\";"],"names":["dragAndDropIcon","React","width","fill","height","viewBox","version","xmlns","xmlnsXlink","id","stroke","strokeWidth","fillRule","cx","cy","r","SortableList","onSort","className","disabled","props","dragContainerRef","defaultOrders","setDefaultOrders","draggingOrders","setDraggingOrders","currentItemNode","setCurrentItemNode","currentItemIndex","setCurrentItemIndex","x","y","delta","setDelta","dragNode","setDragNode","isDragging","setIsDragging","isTranslating","setIsTranslating","affectedIndex","setAffectedIndex","affectedNode","setAffectedNode","onMouseDown","event","index","itemParentNode","target","closest","position","touches","pageX","getBoundingClientRect","left","pageY","top","onDragStart","clonedNode","cloneNode","classList","remove","add","style","document","body","appendChild","dataTransfer","setDragImage","effectAllowed","onDragOver","preventDefault","dropEffect","activeNodeRect","nodeRect","ghostImagePositionTop","clientY","ghostImagePositionBottom","isAboveGhostImage","positionDifference","bottom","isOverlapped","Math","abs","indexOf","transform","offsetHeight","onTransitionEnd","oldOrders","newList","slice","itemIndex","originalItem","find","uniqueKey","onDragEnd","stopPropagation","Array","from","current","children","forEach","element","map","onItemSwap","currentIndex","swapIndex","focusTarget","swapItem","focus","onKeyDown","selectedItemIndex","Number","dataset","_dataset","key","Key","oldItemIndex","length","nextElementSibling","previousElementSibling","newOrderList","filter","item","type","displayName","console","warn","role","classnames","tabIndex","ref","SortableItemWrapper","isActive","onTouchStart","onMouseUp","onTouchEnd","Child","isDisabled","draggable","SortableItem","_Child$props","importString","require","value","setValue","label","checked","array","setArray","useDynamicForm","items","controlType","renderControls","renderForm","controls","state","disabledItem","floor","random","Docs","mainFile","example","list","oldArray","sort","a","b","simple","Checkbox","name","onChange","checkbox","code","DragDropTouch","safeDocument","safeNavigator","navigator","DragDropTouch_1","DataTransfer","this","_dropEffect","_effectAllowed","_data","Object","defineProperty","prototype","get","set","enumerable","configurable","keys","clearData","toLowerCase","getData","setData","img","offsetX","offsetY","ddt","_instance","_imgCustom","_imgOffset","_lastClick","supportsPassive","addEventListener","passive","maxTouchPoints","d","ts","_touchstart","bind","tm","_touchmove","te","_touchend","opt","capture","getInstance","e","_this","_shouldHandle","Date","now","_DBLCLICK","_dispatchEvent","_reset","src","_closestDraggable","_dragSource","_ptDown","_getPoint","_lastTouch","setTimeout","_img","_CTXMENU","_ISPRESSHOLDMODE","_pressHoldInterval","_isDragEnabled","_PRESSHOLDAWAIT","_shouldCancelPressHoldMove","_shouldHandleMove","_shouldHandlePressHoldMove","_getTarget","_shouldStartDragging","_createImage","_lastTarget","_moveImage","_isDropZone","_destroyImage","defaultPrevented","_getDelta","_PRESSHOLDMARGIN","_THRESHOLD","_PRESSHOLDTHRESHOLD","_dataTransfer","clearInterval","page","clientX","p","pt","el","elementFromPoint","getComputedStyle","pointerEvents","parentElement","_copyStyle","rc","opacity","_OPACITY","toString","removeChild","requestAnimationFrame","s","zIndex","round","_copyProps","dst","i","_rmvAtts","att","removeAttribute","HTMLCanvasElement","cSrc","cDst","getContext","drawImage","cs","evt","createEvent","t","initEvent","button","which","buttons","_kbdProps","_ptProps","dispatchEvent","hasAttribute","split"],"sourceRoot":""}